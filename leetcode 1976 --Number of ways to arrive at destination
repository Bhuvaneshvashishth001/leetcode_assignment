class Solution {
    class Pair{
        int node;
        long dist;
        public Pair(int node,long dist){
            this.node = node;
            this.dist = dist;
        }
    }
    public int countPaths(int n, int[][] roads) {
        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();
       for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
       }
        for(int edge[] : roads){
            if(edge.length>0){
                int u=edge[0];
                int v=edge[1];
                int w=edge[2];
                adj.get(u).add(new Pair(v,w));
                adj.get(v).add(new Pair(u,w));
            }   
        }
       long[] dist = new long[n];
        PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> Long.compare(a.dist, b.dist));
        int ways[] = new int[n];
        Arrays.fill(dist, Long.MAX_VALUE);
        dist[0] = 0;
        ways[0] = 1;
        queue.offer(new Pair(0,0));
        int MOD = (int)1e9+7;
        while(!queue.isEmpty()){
            Pair P = queue.poll();
            int node = P.node;
            long dis = P.dist;
            if (dis>dist[node]) continue;
            for(Pair p:adj.get(node)){
                int x =p.node;
                long y = p.dist+dis;
                if(dist[x]>y){
                    dist[x]=y;
                    ways[x]=ways[node];
                    queue.offer(new Pair(x,y));
                }
                else if(dist[x] ==y){
                    ways[x]=(ways[x]+ways[node])%MOD;
                }
            }
        }
        return ways[n-1];
    }
}
